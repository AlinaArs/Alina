# 1
'''Ниже представлен текст одной из классических головоломок и, по совместительству, алгоритмических задач по программированию. С ней знакомы многие, в том числе и те, кто с программированием никак не связан.
Головоломка “Ханойские башни” состоит из трех стержней, пронумерованных числами 1, 2, 3. На стержень 1 надета пирамидка из N дисков различного диаметра в порядке возрастания диаметра. Диски можно перекладывать с одного стержня на другой по одному, при этом диск нельзя класть на диск меньшего диаметра. Необходимо переложить всю пирамидку со стержня 1 на стержень 3 за минимальное число перекладываний.
Напишите программу, которая решает головоломку; для данного числа дисков N печатает последовательность перекладываний в формате A B C, где A — номер перекладываемого диска, B — номер стержня с которого снимается данный диск, C — номер стержня на который надевается данный диск.
Например, строка 1 2 3 означает перемещение диска номер 1 со стержня 2 на стержень 3. В одной строке печатается одна команда. Диски пронумерованы числами от 1 до n в порядке возрастания диаметров.
Программа должна вывести минимальный (по количеству произведенных операций) способ перекладывания пирамидки из данного числа дисков. Решение оформите в виде функции move (n, x, y), которая печатает последовательность перекладываний дисков для перемещения пирамидки высоты N со стержня номер X на стержень номер Y.
'''


def moves(n, x=1, y=3):
    if n == 1:
        print(f'Переложит диск {n} со стержня номер {x} на стержень номер {y}')
    else:
        moves(n - 1, x, 6 - x - y)
        print(f'Переложит диск {n} со стержня номер {x} на стержень номер {y}')
        moves(n - 1, 6 - x - y, y)


disc_number = int(input('Введите количество дисков:'))
moves(disc_number)

# 2
site = {
    'html': {
        'head': {
            'title': 'Мой сайт'
        },
        'body': {
            'h2': 'Здесь будет мой заголовок',
            'div': 'Тут, наверное, какой-то блок',
            'p': 'А вот здесь новый абзац'
        }
    }
}


def search(d, kk, lv=-1):
    if (lv == -1):
        res = []
        for k in d.keys():
            if k == kk:
                res = res + [d[k]]
            if type(d[k]) is dict:
                res = res + search(d[k], kk, lv=-1)
        return res
    else:
        if (lv == 0):
            return []
        else:
            res = []
            for k in d.keys():
                if k == kk:
                    res = res + [d[k]]
                if type(d[k]) is dict:
                    res = res + search(d[k], kk, lv - 1)
            return res
print(search(site, 'p'))
print(search(site, 'p', lv = 3))

# 4
'''Даны список букв (letters) и список цифр (numbers). Каждый список состоит из N элементов. Создайте кортежи из пар элементов списков и запишите их в список results. Не используйте функцию zip. Решите задачу “в одну строку”     (не считая print(results))
'''
strings: list[str] = ['a', 'b', 'c', 'd', 'e']
numbers: list[int] = [1, 2, 3, 4, 5, 6, 7, 8]
print(tuple(zip(strings,numbers)))

# 5
'''Дано натуральное число N. Выведите слово YES, если число N является точной степенью двойки, или слово NO в противном случае.
Операцией возведения в степень пользоваться нельзя!'''
N = int(input())
i = 1
while i < N:
    i = i * 2
if i == N:
    print("YES")
else:
    print("NO")

# 6
'''Дано число n, десятичная запись которого не содержит нулей. Получите число, записанное теми же цифрами, но в противоположном порядке.
При решении этой задачи нельзя использовать циклы, строки, списки, массивы, разрешается только рекурсия и целочисленная арифметика.
Функция должна возвращать целое число, являющееся результатом работы программы, выводить число по одной цифре нельзя.
'''
reverse_num = 0
num = 111.43
def recursion_number (num):
    global reverse_num
    if num > 0:
        reminder = num % 10
        reverse_num = (reverse_num * 10) + reminder
        recursion_number(num // 10)
    return reverse_num

reverse_num = recursion_number(num)
print(reverse_num)